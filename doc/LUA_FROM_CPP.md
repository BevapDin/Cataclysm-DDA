# Using Lua from C++

## Build

The Lua library can be accessed via a set of C functions, it also supports callbacks from Lua code via C functions. The details of that interface are hidden in a separate library called `libcatalua.a` and exposed via headers in `src/lua`.

The library is compiled from different files based on whether Lua is enabled or not. The interface is common for both build types. This means one can do `make LUA=1` (Lua build) and `make` (non-Lua build) without issuing `make clean` (but one has to remove the `libcatalua.a` file). The C++ files do not contain any check for Lua, instead they either assume Lua is enabled (and they are only build in Lua builds), or it's disabled (and files are only build in non-Lua builds) or they don't care and `make` selects which files are to be compiled for the current build.

For non-Lua builds, `make` selects different files to build the library from. Those files assume Lua is not enabled and don't use it. They provide dummy implementations (that essentially do nothing) so the interface is still implemented.


## Lua bindings

The Lua engine can be instructed to call specific C functions when the Lua script contains matching function calls. Those C functions are supposed to extract the arguments as given by the Lua script, perform their action and return values to Lua.

C++ functions and classes can not be exported directly, they need some wrapping code. In our case, that code is generated by a Lua script taking an abstract definition of the C++ classes and functions. That definition can be generated by a C++ program (requires `clang` to parse the C++ code, see below), but it can be created manually as well.

The generated bindings are than compiled and linked like any other C++ code.

Classes and functions that have not been exported that way won't be available to Lua scripts.

## Lua bindings definition

The bindings are stored as Lua code (as it is used by a Lua script). It contains basically three Lua maps:

- `classes`: contains all the exported C++ classes and their exported members.
- `enums`: contains the enumerations and their values (strings, the numeric values is supplied indirectly by the C++ compiler when the bindings are compiled).
- `global_functions`: global functions.

## Calling Lua from withing C++

Lua code can be run via the `catalua::call<R, ...>( ... )` (see "src/lua/call.h"). See there for how to use it. It should only be used for scripts stored directly in the C++ code, not for anything loaded at run time.

For scripts loaded at run time, use `catalua::script<T, ...>` (see "src/lua/script.h"). It is basically a `std::string` that can be invoked like a normal function and can be loaded from JSON.

Additionally there is `catalua::scriptable_value<T,  ...>` (see "src/lua/scriptable_value.h"). It contains either an actual C++ value or a script that is supposed to return such a value. This class allows loading either a simple value (e.g. a number) from JSON or a script that will be run whenever the value is needed.

Finally there are mod callbacks `catalua::mod_callback<...>( ... )` (see "src/lua/call.h"). Those are similar to script calls, but they take the callback name instead of a script (and optionally any number of arguments). Mods can register themself (via Lua code) to receive those callbacks. This feature is not related to JSON in any way.


